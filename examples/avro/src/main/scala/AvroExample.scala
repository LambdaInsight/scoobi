/**
 * Copyright 2011,2012 National ICT Australia Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.nicta.scoobi.examples

// test.Weather is a class that has been generated by sbt-avro
// based on the schema at: src/main/avro/weather.avsc

import org.apache.avro.specific.SpecificRecordBase
import org.apache.hadoop.io.serializer.avro.AvroRecord

// make sure to run "sbt avro:generate" to generate the sources in:
// target/scala-2.x/src_managed/main/compiled_avro
import test.AvroWeather
import com.nicta.scoobi.Scoobi._


object AvroExample extends ScoobiApp {

  def run() {

    // There are WireFormat's for avro records, so there's no problem in creating DLists of them

    val weatherList: DList[AvroWeather] = DList(
      new AvroWeather("Town Hall", 925, 23),
      new AvroWeather("Red Fern", 1201, -55),
      new AvroWeather("Bondi Junction", 1920, 100))

    // and they can easily be persisted, using our schema ( at src/main/avro/weather.avsc )
    weatherList.toAvroFile("avro-test-output", overwrite=true).persist

    // and of course, it's easy to read avro files to disk, given a schema!
    val weatherReadList: DList[AvroWeather] =
      fromAvroFile[AvroWeather]("avro-test-output")

    weatherReadList.toTextFile("avro-test-output2", overwrite=true).persist

    /*
    FIXME: below will generate:
    java.lang.InternalError: Malformed class name
	at java.lang.Class.getSimpleName(Class.java:1190)
	at com.nicta.scoobi.core.LowPriorityWireFormatImplicits$AvroWireFormat.toString(WireFormat.scala:207)
	at java.lang.String.valueOf(String.java:2847)
	at scala.collection.mutable.StringBuilder.append(StringBuilder.scala:197)
	at com.nicta.scoobi.impl.plan.comp.Return.<init>(ProcessNode.scala:273)
	at com.nicta.scoobi.impl.plan.comp.Return$.apply(ProcessNode.scala:296)
	at com.nicta.scoobi.impl.plan.DObjectImpl$.apply(DObjectImpl.scala:75)
	at com.nicta.scoobi.application.DObjects$.apply(DObject.scala:26)
  ...

    // The other plugin we are using, generates AvroSchema's for case-classes, as we have to do
    // is extend AvroRecord, and make sure all the members are 'var's
    case class Person(var name: String, var awesomeness: Int)
      extends AvroRecord

    implicit val _personFmt: WireFormat[Person] = mkCaseWireFormat(Person, Person.unapply _)
    val p = new Person("Eric", 10)

    // There are also WireFormat's available, so there's no problem doing all the cool stuff
    // that scoobi allows. e.g.
    val joined: DList[(Person, AvroWeather)] = DObject(p) join weatherReadList

    // and let's dump it to a text file, so you can easily verify it worked ;D
    joined.toTextFile("avro-joined-output", overwrite=true).persist
    */
  }
}
